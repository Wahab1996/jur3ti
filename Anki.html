<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>مولّد ملف Anki من نص (يدعم MCQ)</title>
<style>
  :root { --gap:12px; --radius:12px; --shadow:0 6px 18px rgba(0,0,0,.08); }
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; background:#0f172a; color:#e2e8f0; margin:0; }
  .wrap { max-width: 1100px; margin: 40px auto; padding: 0 16px; }
  .card { background:#0b1220; border:1px solid #1f2937; border-radius: var(--radius); box-shadow: var(--shadow); }
  header { padding: 18px 20px; border-bottom:1px solid #1f2937; display:flex; gap:10px; align-items:center; justify-content:space-between; }
  header h1 { font-size: 18px; margin:0; font-weight:700; letter-spacing:.3px; }
  header small { opacity:.8; }
  .grid { display:grid; gap: var(--gap); grid-template-columns: 1fr; padding: 16px; }
  @media (min-width: 960px){ .grid{ grid-template-columns: 1.2fr .8fr; } }
  textarea { width: 100%; min-height: 380px; resize: vertical; padding:14px; border-radius: 10px; border:1px solid #23304a; background:#0b1426; color:#e2e8f0; line-height:1.6; }
  .panel { display:grid; gap: var(--gap); }
  .row { display:grid; gap:10px; grid-template-columns: 1fr 1fr; }
  label { font-size: 13px; opacity:.9; margin-bottom:6px; display:block; }
  input, select { width:100%; padding:12px; border-radius:10px; border:1px solid #23304a; background:#0b1426; color:#e2e8f0; }
  input::placeholder { color:#94a3b8; opacity:.7; }
  button { padding: 12px 14px; border-radius: 10px; border:1px solid #334155; background:#1e293b; color:#e2e8f0; cursor:pointer; font-weight:600; }
  button.primary { background: #22c55e; border-color:#16a34a; color:#062d17; }
  button.ghost { background: transparent; }
  .help { font-size:13px; line-height:1.7; background:#0a1222; border:1px dashed #29354e; padding:12px; border-radius:10px; }
  table { width:100%; border-collapse: collapse; background:#0b1426; border:1px solid #22314f; border-radius:10px; overflow:hidden; }
  th, td { text-align: start; padding: 10px 12px; border-bottom:1px solid #1e2a45; vertical-align: top; }
  th { background:#0e1830; font-weight:700; }
  .muted { opacity:.7; font-size:12px; }
  .badge { display:inline-block; padding:4px 8px; border-radius:999px; background:#0b1d39; border:1px solid #1f3b70; font-size:12px; }
  .footer { padding:14px 16px; display:flex; gap:10px; align-items:center; justify-content:space-between; border-top:1px solid #1f2937;}
  .note { font-size:12px; opacity:.8; }
  .pill { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <h1>مولّد ملف Anki من نص</h1>
        <small class="badge">Basic • Cloze • MCQ</small>
      </header>

      <div class="grid">
        <section>
          <label for="inputText">الصق النص هنا</label>
          <textarea id="inputText" placeholder="أمثلة سريعة:

[MCQ: كل سؤال فقرة مستقلة]
ما هو الهرمون الذي يخفض سكر الدم؟
- *الأنسولين
- الجلوكاجون
- الكورتيزول
- هرمون النمو

What is the HbA1c diagnostic cutoff for diabetes?
A) 5.6%
B) 6.5% *
C) 7.0%
D) 8.0%

Vitamin B12 deficiency causes:
• Macrocytic anemia *
• Microcytic anemia
• Normocytic anemia
Answer: A

[Q→A]
What is insulin? :: A hormone that lowers blood glucose

[Cloze]
Insulin is secreted by the {{c1::beta cells}} of the {{c2::pancreas}}."></textarea>

          <div class="help">
            <b>أوضاع التحويل:</b>
            <ul>
              <li><b>MCQ:</b> كل سؤال فقرة (افصل بأسطر فارغة). أول سطر هو السؤال، والأسطر التالية خيارات. صيغ الخيارات المقبولة:
                <br>• <code>- الخيار</code> أو <code>• الخيار</code> أو <code>A) الخيار</code> أو <code>A. الخيار</code>.
                <br>• ضع نجمة <code>*</code> على الخيار الصحيح (قبل النص أو بعده)، أو أضف سطرًا: <code>Answer: A</code> أو <code>Answer: النص الصحيح</code>.
              </li>
              <li><b>سؤال→جواب (Q→A):</b> كل سطر بطاقة، افصل بـ <code>::</code>.</li>
              <li><b>Cloze:</b> استخدم <code>{{c1::...}}</code>. كل فقرة بطاقة.</li>
            </ul>
            في وضع MCQ، عمود <b>Front</b> يحتوي السؤال + الخيارات، وعمود <b>Back</b> هو الإجابة الصحيحة فقط.
          </div>
        </section>

        <aside class="panel">
          <div class="row">
            <div>
              <label for="mode">الوضع</label>
              <select id="mode">
                <option value="mcq">MCQ (اختيار من متعدد)</option>
                <option value="qa">سؤال → جواب (Q→A)</option>
                <option value="cloze">Cloze (إخفاء)</option>
                <option value="one">سطر → بطاقة (وجه واحد)</option>
              </select>
            </div>
            <div>
              <label for="deck">اسم المجموعة (Deck) — اختياري</label>
              <input id="deck" type="text" placeholder="مثال: Internal Medicine" />
            </div>
          </div>

          <div class="row" id="qaOptions">
            <div>
              <label for="delimiter">الفاصل بين السؤال والجواب (لوضع Q→A)</label>
              <input id="delimiter" type="text" value="::">
            </div>
            <div>
              <label for="tags">وسوم (Tags) — اختياري</label>
              <input id="tags" type="text" placeholder="مثال: MCQ;exam;cards">
            </div>
          </div>

          <div class="pill">
            <button id="previewBtn">معاينة البطاقات</button>
            <button id="downloadBtn" class="primary">تنزيل ملف CSV للـ Anki</button>
            <button id="clearBtn" class="ghost">تفريغ الحقول</button>
          </div>

          <div class="note">
            CSV بترميز UTF-8 (مع BOM). عند الاستيراد اختر نوع المذكرة <b>Basic</b> واربط الأعمدة: Front → Back. (أو Cloze لو وضع الإخفاء).
          </div>
        </aside>
      </div>

      <div class="grid" style="grid-template-columns:1fr;">
        <section>
          <label>المعاينة <span class="muted">(أول 100 بطاقة)</span></label>
          <div id="preview"></div>
        </section>
      </div>

      <div class="footer">
        <div class="note">تلميح: في MCQ سيعرض الوجه الأمامي السؤال + الخيارات، والوجه الخلفي الإجابة الصحيحة (حرف الخيار + النص).</div>
        <div class="note">يعمل محليًا بدون إنترنت.</div>
      </div>
    </div>
  </div>

<script>
(function(){
  const $ = (s)=>document.querySelector(s);

  const inputText = $('#inputText');
  const mode = $('#mode');
  const deck = $('#deck');
  const delimiter = $('#delimiter');
  const tagsInput = $('#tags');
  const qaOptions = $('#qaOptions');
  const previewEl = $('#preview');
  const previewBtn = $('#previewBtn');
  const downloadBtn = $('#downloadBtn');
  const clearBtn = $('#clearBtn');

  mode.addEventListener('change', ()=> {
    qaOptions.style.display = (mode.value === 'qa') ? 'grid' : 'none';
    renderPreview();
  });
  qaOptions.style.display = (mode.value === 'qa') ? 'grid' : 'none';

  clearBtn.addEventListener('click', ()=>{
    inputText.value = '';
    previewEl.innerHTML = '';
  });

  previewBtn.addEventListener('click', renderPreview);
  inputText.addEventListener('input', debounce(renderPreview, 250));

  downloadBtn.addEventListener('click', ()=>{
    const {rows, headers} = buildRows();
    if(!rows.length){ alert('لا توجد بطاقات لتصديرها.'); return; }
    const csv = toCSV([headers, ...rows]);
    const deckName = (deck.value || 'anki').trim().replace(/[\\/:*?"<>|]+/g,'-');
    const blob = new Blob([bomUtf8()+csv], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `${deckName || 'anki'}.csv`;
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  });

  function buildRows(){
    const text = inputText.value.replace(/\r\n/g, '\n');
    const tagString = normalizeTags(tagsInput.value);
    const deckName = (deck.value || '').trim();

    if(mode.value === 'qa'){
      const delim = delimiter.value || '::';
      const lines = text.split('\n').map(s=>s.trim()).filter(Boolean);
      const rows = lines.map(line=>{
        const idx = line.indexOf(delim);
        let front = line, back = '';
        if(idx >= 0){ front = line.slice(0, idx).trim(); back  = line.slice(idx + delim.length).trim(); }
        return [front, back, deckName, tagString];
      });
      return { headers: ['Front','Back','Deck','Tags'], rows };
    }

    if(mode.value === 'one'){
      const lines = text.split('\n').map(s=>s.trim()).filter(Boolean);
      const rows = lines.map(line=>[line, '', deckName, tagString]);
      return { headers: ['Front','Back','Deck','Tags'], rows };
    }

    if(mode.value === 'cloze'){
      const chunks = splitParagraphs(text).filter(s=>s.trim().length>0);
      const rows = chunks.map(ch => [ch.trim(), deckName, tagString]);
      return { headers: ['Text','Deck','Tags'], rows };
    }

    // MCQ
    const paras = splitParagraphs(text).filter(p=>p.trim().length>0);
    const rows = [];
    for(const p of paras){
      const parsed = parseMCQParagraph(p);
      if(parsed){
        const {question, options, correctIndex} = parsed;
        const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const optLines = options.map((opt,i)=>`${letters[i]}. ${opt}`).join('<br>');
        const front = `${question}<br><br>${optLines}`;
        let back = '';
        if(correctIndex != null){
          const letter = letters[correctIndex];
          back = `${letter}. ${options[correctIndex]}`;
        }
        rows.push([front, back, deckName, tagString]);
      }
    }
    return { headers: ['Front','Back','Deck','Tags'], rows };
  }

  function parseMCQParagraph(p){
    const lines = p.split('\n').map(s=>s.trim()).filter(Boolean);
    if(!lines.length) return null;
    const question = lines[0];
    const rest = lines.slice(1);

    let options = [];
    let answerExplicit = null;

    // detect explicit answer line
    for(const ln of rest){
      const m = ln.match(/^(?:answer|ans|correct)\s*[:\-]\s*(.+)$/i);
      if(m){ answerExplicit = m[1].trim(); }
    }

    // extract option lines
    for(let ln of rest){
      // skip answer line
      if(/^(?:answer|ans|correct)\s*[:\-]/i.test(ln)) continue;

      // Accept forms: "- text", "• text", "* text", "A) text", "A. text", "a) text"
      let m;
      // leading bullet with optional star
      m = ln.match(/^(?:[-•▪—–]|\*)\s*(.+)$/);
      if(m){ options.push(m[1].trim()); continue; }
      // lettered A) or A. or A-
      m = ln.match(/^[A-Za-z]\s*[\)\.\-]\s*(.+)$/);
      if(m){ options.push(m[1].trim()); continue; }
      // plain line (fallback): treat as option if we already have at least one option
      if(options.length>0){ options.push(ln); }
    }

    if(options.length === 0) return null;

    // find correct index
    let correctIndex = null;

    // star-marked options: allow "*" anywhere around start or end
    for(let i=0;i<rest.length;i++){
      let raw = rest[i];
      if(/^(?:answer|ans|correct)\s*[:\-]/i.test(raw)) continue;
      // capture if the same text appears with * at start or end
      const starStart = raw.match(/^\*\s*(.+)$/);
      const starEnd   = raw.match(/^(.+?)\s*\*$/);
      if(starStart || starEnd){
        const clean = (starStart? starStart[1] : starEnd[1]).trim();
        // find index in options by text
        const idx = options.findIndex(o=>normalize(o)===normalize(clean));
        if(idx>=0) correctIndex = idx;
      }
    }

    // explicit answer resolution
    if(answerExplicit && correctIndex==null){
      const ans = answerExplicit.trim();
      // letter form
      const letter = ans.match(/^[A-Za-z]$/) || ans.match(/^[A-Za-z][\)\.\-]?$/);
      if(letter){
        const L = ans[0].toUpperCase();
        const idx = L.charCodeAt(0) - 65;
        if(idx>=0 && idx<options.length) correctIndex = idx;
      } else {
        // match by text
        const idxByText = options.findIndex(o=>normalize(o)===normalize(ans));
        if(idxByText>=0) correctIndex = idxByText;
      }
    }

    return {question, options, correctIndex};
  }

  function normalize(s){ return (s||'').toString().replace(/\s+/g,' ').trim().toLowerCase(); }

  function renderPreview(){
    const {rows, headers} = buildRows();
    const max = Math.min(rows.length, 100);
    if(max === 0){ previewEl.innerHTML = '<div class="muted">لا توجد معاينة بعد.</div>'; return; }
    const head = '<tr>' + headers.map(h=>`<th>${escapeHtml(h)}</th>`).join('') + '</tr>';
    const body = rows.slice(0, max).map(r => '<tr>'+ r.map(c=>`<td>${escapeHtmlHTML(c)}</td>`).join('') + '</tr>').join('');
    previewEl.innerHTML = `<div style="overflow:auto; border-radius:10px;"><table>${head}${body}</table></div>
      <div class="muted" style="margin-top:8px;">إجمالي البطاقات: ${rows.length}${rows.length>max?` — المعروض ${max}`:''}</div>`;
  }

  function toCSV(rows){
    return rows.map(r=> r.map(csvEscape).join(',')).join('\n');
  }

  function csvEscape(v){
    v = (v ?? '').toString();
    if(/[",\n]/.test(v)){ v = '"' + v.replace(/"/g,'""') + '"'; }
    return v;
  }

  function escapeHtml(s){
    return (s??'').toString()
      .replace(/&/g,'&amp;').replace(/</g,'&lt;')
      .replace(/>/g,'&gt;').replace(/"/g,'&quot;')
      .replace(/'/g,'&#039;');
  }

  // for preview: allow <br> in MCQ front
  function escapeHtmlHTML(s){
    const safe = (s??'').toString()
      .replace(/&/g,'&amp;').replace(/</g,'&lt;')
      .replace(/>/g,'&gt;').replace(/"/g,'&quot;')
      .replace(/'/g,'&#039;');
    return safe.replace(/&lt;br&gt;/g,'<br>');
  }

  function splitParagraphs(t){
    return t.split(/\n\s*\n+/);
  }

  function normalizeTags(s){
    return (s||'').trim().replace(/[;,]+/g,' ').replace(/\s+/g,' ');
  }

  function bomUtf8(){ return '\uFEFF'; }

  function debounce(fn, ms){
    let id; return (...args)=>{ clearTimeout(id); id = setTimeout(()=>fn.apply(null,args), ms); }
  }

  // initial
  renderPreview();
})();
</script>
</body>
</html>